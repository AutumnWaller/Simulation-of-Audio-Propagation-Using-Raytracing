// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> skyboxTexture;
SamplerState sampler_skyboxTexture;
static const float PI = 3.14159265f;
float4x4 worldMat;
float4x4 inverseProjMat;
float4 directionalLight;
float3 minBounds;
float3 maxBounds;

struct Ray {
    float3 origin;
    float3 direction;
    float3 energy;
};


Ray CreateRay(float3 _origin, float3 _direction) {
    Ray r;
    r.origin = _origin;
    r.direction = _direction;
    r.energy = float3(1.0f, 1.0f, 1.0f);
    return r;
}

Ray CreateCameraRay(float2 _texCoords) {
    float3 origin = mul(worldMat, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 dir = mul(inverseProjMat, float4(_texCoords, 0.0f, 1.0f)).xyz;
    dir = mul(worldMat, float4(dir, 0.0f)).xyz;
    dir = normalize(dir);
    return CreateRay(origin, dir);
}

struct RayHit {
    float3 position;
    float distance;
    float3 normal;
};

RayHit CreateRayHit() {
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

struct Cuboid {
    float3 colour;
    float3 min;
    float3 max;
};

Cuboid CreateCuboid(float3 _min, float3 _max, float3 _colour) {
    Cuboid cuboid;
    cuboid.colour = _colour;
    cuboid.min = _min;
    cuboid.max = _max;

    return cuboid;
}

void Swap(inout float _a, inout float _b) {
    float temp = _a;
    _a = _b;
    _b = temp;
}

float Sq(float _a) {
    return _a * _a;
}

float Sqr(float _a) {
    return _a / _a;
}

void AABBIntersect(Ray _ray, inout RayHit _rayHit, Cuboid _cuboid) {
    float tXMin = (_cuboid.min.x - _ray.origin.x) / _ray.direction.x;
    float tXMax = (_cuboid.max.x - _ray.origin.x) / _ray.direction.x;

    float3 invDir = 1 / _ray.direction;
    if (invDir.x >= 0) {
        tXMin = (_cuboid.min.x - _ray.origin.x) / _ray.direction.x;
        tXMax = (_cuboid.max.x - _ray.origin.x) / _ray.direction.x;
    }
    else {
        tXMin = (_cuboid.max.x - _ray.origin.x) / _ray.direction.x;
        tXMax = (_cuboid.min.x - _ray.origin.x) / _ray.direction.x;
    }

    float tYMin = (_cuboid.min.y - _ray.origin.y) / _ray.direction.y;
    float tYMax = (_cuboid.max.y - _ray.origin.y) / _ray.direction.y;

    if (invDir.y >= 0) {
        tYMin = (_cuboid.min.y - _ray.origin.y) / _ray.direction.y;
        tYMax = (_cuboid.max.y - _ray.origin.y) / _ray.direction.y;
    }
    else {
        tYMin = (_cuboid.max.y - _ray.origin.y) / _ray.direction.y;
        tYMax = (_cuboid.min.y - _ray.origin.y) / _ray.direction.y;
    }

    if (tXMin > tYMax || tYMin > tXMax)
        return;

    if (tYMin > tXMin)
        tXMin = tYMin;

    if (tYMax < tXMax)
        tXMax = tYMax;

    float tZMin = (_cuboid.min.z - _ray.origin.z) / _ray.direction.z;
    float tZMax = (_cuboid.max.z - _ray.origin.z) / _ray.direction.z;
    

    if (invDir.z >= 0) {
        tZMin = (_cuboid.min.z - _ray.origin.z) / _ray.direction.z;
        tZMax = (_cuboid.max.z - _ray.origin.z) / _ray.direction.z;
    }
    else {
        tZMin = (_cuboid.max.z - _ray.origin.z) / _ray.direction.z;
        tZMax = (_cuboid.min.z - _ray.origin.z) / _ray.direction.z;
    }

    if (tXMin > tZMax || tZMin > tXMax)
        return;

    if (tZMin > tXMin)
        tXMin = tZMin;

    if (tZMax < tXMax)
        tXMax = tZMax;

    float3 dir = float3(_ray.direction.x * tXMin, _ray.direction.y * tYMin, _ray.direction.z * tZMin);


    float dist = (tXMin + tYMin + tZMin);
    if (dist > _rayHit.distance || dist > 0)
        return;
    _rayHit.distance = dist;
    _rayHit.position = _ray.origin + dist * _ray.direction;
    _rayHit.normal = normalize(_rayHit.position - _ray.direction);
}



void IntersectGroundPlane(Ray _ray, inout RayHit _rayHit) {
    float dist = -_ray.origin.y / _ray.direction.y;
    if (dist > 0 && dist < _rayHit.distance) {
        _rayHit.distance = dist;
        _rayHit.position = _ray.origin + dist * _ray.direction;
        _rayHit.normal = float3(0, 1, 0);
    }
}



RayHit Trace(Ray _ray) {
    RayHit rayHit = CreateRayHit();
    Cuboid cuboid = CreateCuboid(float3(0, 0, 0), minBounds, maxBounds);
    //Cuboid cuboid2 = CreateCuboid(float3(5, 0, 0), float3(2.5f, 1, 6), float3(0.5f, 0.5f, 0.2f));
    AABBIntersect(_ray, rayHit, cuboid);
    //AABBIntersect(_ray, rayHit, cuboid2);
    IntersectGroundPlane(_ray, rayHit);
    return rayHit;
}

float3 Shade(inout Ray _ray, RayHit _rayHit) {
    if (_rayHit.distance < 1.#INF) {
        float3 specular = float3(0.6f, 0.6f, 0.6f);
        float3 albedo = float3(0.8f, 0.8f, 0.8f);
        _ray.origin = _rayHit.position + _rayHit.normal * 0.001f;
        _ray.direction = reflect(_ray.direction, _rayHit.normal);
        _ray.energy *= specular;
        bool shadow = false;
        Ray shadowRay = CreateRay(_rayHit.position + _rayHit.normal * 0.001f, -1 * directionalLight.xyz);
        RayHit shadowHit = Trace(shadowRay);
        if (shadowHit.distance != 1.#INF) {
            return float3(0.0f, 0.0f, 0.0f);
        }
        return saturate(dot(_rayHit.normal, directionalLight.xyz) * -1) * directionalLight.w * albedo;
    }
    else {
        _ray.energy = float3(0, 0, 0);
        float theta = acos(_ray.direction.y) / -PI;
        float phi = atan2(_ray.direction.x, _ray.direction.z) / -PI * 0.5f;
        return skyboxTexture.SampleLevel(sampler_skyboxTexture, float2(phi, theta), 0).xyz;
    }
}

void Lighting(float4 _light, inout RayHit _rayHit) {
    _rayHit.normal -= saturate(dot(_rayHit.normal, _light.xyz) * -1);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width;
    uint height;
    Result.GetDimensions(width, height);
    float2 texCoords = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    float3 result = float3(0, 0, 0);
    Ray r = CreateCameraRay(texCoords);

    for (int i = 0; i < 8; i++) {
        RayHit hit = Trace(r);
        result += r.energy * Shade(r, hit);
        Lighting(directionalLight, hit);
        if (r.energy.x == 0 && r.energy.y == 0 && r.energy.z == 0)
            break;
    }
    Result[id.xy] = float4(result, 1);
}
