// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> skyboxTexture;
SamplerState sampler_skyboxTexture;
static const float PI = 3.14159265f;
float4x4 worldMat;
float4x4 inverseProjMat;

struct Ray {
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 _origin, float3 _direction) {
    Ray r;
    r.origin = _origin;
    r.direction = _direction;
    return r;
}

Ray CreateCameraRay(float2 _texCoords) {
    float3 origin = mul(worldMat, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 dir = mul(inverseProjMat, float4(_texCoords, 0.0f, 1.0f)).xyz;
    dir = mul(worldMat, float4(dir, 0.0f)).xyz;
    dir = normalize(dir);
    return CreateRay(origin, dir);
}

struct RayHit {
    float3 position;
    float distance;
    float3 normal;
};

RayHit CreateRayHit() {
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 999999;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

struct Cuboid {
    float3 colour;
    float3 min;
    float3 max;
};

Cuboid CreateCuboid(float3 _min, float3 _max, float3 _colour) {
    Cuboid cuboid;
    cuboid.colour = _colour;
    cuboid.min = _min;
    cuboid.max = _max;

    return cuboid;
}

void Swap(inout float _a, inout float _b) {
    float temp = _a;
    _a = _b;
    _b = temp;
}

void AABBIntersect(Ray _ray, inout RayHit _rayHit, Cuboid _cuboid) {
    float tXMin = (_cuboid.min.x - _ray.origin.x) / _ray.direction.x;
    float tXMax = (_cuboid.max.x - _ray.origin.x) / _ray.direction.x;

    if (tXMin > tXMax)
        Swap(tXMin, tXMax);

    float tYMin = (_cuboid.min.y - _ray.origin.y) / _ray.direction.y;
    float tYMax = (_cuboid.max.y - _ray.origin.y) / _ray.direction.y;

    if (tYMin > tYMax)
        Swap(tYMin, tYMax);

    if (tXMin > tYMax || tYMin > tXMax)
        return;

    if (tYMin > tXMin)
        tXMin = tYMin;

    if (tYMax < tXMax)
        tXMax = tYMax;

    float tZMin = (_cuboid.min.z - _ray.origin.z) / _ray.direction.z;
    float tZMax = (_cuboid.max.z - _ray.origin.z) / _ray.direction.z;
    
    if (tZMin > tZMax)
        Swap(tZMin, tZMax);

    if (tXMax > tZMax || tZMin > tXMax)
        return;

    if (tZMin > tXMin)
        tXMin = tZMin;

    if (tZMax < tXMax)
        tXMax = tZMax;

    //float intersectMinX = (_cuboid.min.x - _ray.origin.x) / _ray.direction.x;
    //float intersectMinY = (_cuboid.min.y - _ray.origin.y) / _ray.direction.y;
    //float intersectMinZ = (_cuboid.min.z - _ray.origin.z) / _ray.direction.z; 
    //float intersectMaxX = (_cuboid.max.x - _ray.origin.x) / _ray.direction.x;
    //float intersectMaxY = (_cuboid.max.y - _ray.origin.y) / _ray.direction.y;
    //float intersectMaxZ = (_cuboid.max.z - _ray.origin.z) / _ray.direction.z;

    //float intersectMin = max(intersectMinX, intersectMinY);
    //float intersectMax = min(intersectMinX, intersectMinY);

    //if (intersectMinX > intersectMaxY || intersectMinY > intersectMaxX)
    //    return;

    //if (intersectMin > intersectMaxZ || intersectMinZ > intersectMax)
    //    return;

    //if (intersectMinZ > intersectMin)
    //    intersectMin = intersectMinZ;

    //if (intersectMaxZ < intersectMax)
    //    intersectMax = intersectMaxZ;


    _rayHit.normal = _cuboid.colour;
    _rayHit.position = _ray.origin + float3(tXMin, tYMin, tZMin);
    _rayHit.distance = _ray.origin.x + _ray.direction.x;


}



void IntersectGroundPlane(Ray _ray, inout RayHit _rayHit) {
    float dist = -_ray.origin.y / _ray.direction.y;
    if (dist > 0 && dist < _rayHit.distance) {
        _rayHit.distance = dist;
        _rayHit.position = _ray.origin + dist * _ray.direction;
        _rayHit.normal = float3(0.0f, 1.0f, 0.0f);
    }
}

float3 Shade(inout Ray _ray, RayHit _rayHit) {
    if (_rayHit.distance < 999999) {
        return _rayHit.normal;
    }
    //else {
    //    float theta = acos(_ray.direction.y) / -PI;
    //    float phi = atan2(_ray.direction.x, -_ray.direction.x) / -PI * 0.5f;
    //    return skyboxTexture.SampleLevel(sampler_skyboxTexture, float2(phi, theta), 0).xyz;
    //}
    return float3(0, 0, 0);
}

RayHit Trace(Ray _ray) {
    RayHit rayHit = CreateRayHit();
    Cuboid cuboid = CreateCuboid(float3(0, 0, 0), float3(3, 3, 1), float3(0.5f, 0.5f, 0.2f));
    AABBIntersect(_ray, rayHit, cuboid);
    //IntersectGroundPlane(_ray, rayHit);
    return rayHit;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width;
    uint height;
    Result.GetDimensions(width, height);
    float2 texCoords = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    Ray r = CreateCameraRay(texCoords);
    RayHit hit = Trace(r);
    float3 result = Shade(r, hit);
    Result[id.xy] = float4(result.xyz, 1);
}
