// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> skyboxTexture;
Texture2D<float4> grassTexture;
SamplerState sampler_skyboxTexture;
SamplerState sampler_grassTexture;
static const float PI = 3.14159265f;
float4x4 worldMat;
float4x4 inverseProjMat;

struct Ray {
    float3 origin;
    float3 direction;
};

struct Light {
    float3 pos;
    float3 dir;
    float3 colour;
    float intensity;
};

Light CreateLight(float3 _pos, float3 _dir, float3 _colour, float _intensity) {
    Light l;
    l.pos = _pos;
    l.dir = _dir;
    l.colour = _colour;
    l.intensity = _intensity;
    return l;
}

Ray CreateRay(float3 _origin, float3 _direction) {
    Ray r;
    r.origin = _origin;
    r.direction = _direction;
    return r;
}

Ray CreateCameraRay(float2 _texCoords) {
    float3 origin = mul(worldMat, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 dir = mul(inverseProjMat, float4(_texCoords, 0.0f, 1.0f)).xyz;
    dir = mul(worldMat, float4(dir, 0.0f)).xyz;
    dir = normalize(dir);
    return CreateRay(origin, dir);
}

struct RayHit {
    float3 position;
    float distance;
    float3 normal;
};

RayHit CreateRayHit() {
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 999999;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

struct Cuboid {
    float3 colour;
    float3 min;
    float3 max;
};

Cuboid CreateCuboid(float3 _min, float3 _max, float3 _colour) {
    Cuboid cuboid;
    cuboid.colour = _colour;
    cuboid.min = _min;
    cuboid.max = _max;

    return cuboid;
}

void Swap(inout float _a, inout float _b) {
    float temp = _a;
    _a = _b;
    _b = temp;
}

void AABBIntersect(Ray _ray, inout RayHit _rayHit, Cuboid _cuboid) {
    float tXMin = (_cuboid.min.x - _ray.origin.x) / -_ray.direction.x;
    float tXMax = (_cuboid.max.x - _ray.origin.x) / -_ray.direction.x;

    if (tXMin > tXMax)
        Swap(tXMin, tXMax);

    float tYMin = (_cuboid.min.y - _ray.origin.y) / -_ray.direction.y;
    float tYMax = (_cuboid.max.y - _ray.origin.y) / -_ray.direction.y;

    if (tYMin > tYMax)
        Swap(tYMin, tYMax);

    if (tXMin > tYMax || tYMin > tXMax)
        return;

    if (tYMin > tXMin)
        tXMin = tYMin;

    if (tYMax < tXMax)
        tXMax = tYMax;

    float tZMin = (_cuboid.min.z - _ray.origin.z) / -_ray.direction.z;
    float tZMax = (_cuboid.max.z - _ray.origin.z) / -_ray.direction.z;
    
    if (tZMin > tZMax)
        Swap(tZMin, tZMax);

    if (tXMin > tZMax || tZMin > tXMax)
        return;

    if (tZMin > tXMin)
        tXMin = tZMin;

    if (tZMax < tXMax)
        tXMax = tZMax;

    //float intersectMinX = (_cuboid.min.x - _ray.origin.x) / _ray.direction.x;
    //float intersectMinY = (_cuboid.min.y - _ray.origin.y) / _ray.direction.y;
    //float intersectMinZ = (_cuboid.min.z - _ray.origin.z) / _ray.direction.z; 
    //float intersectMaxX = (_cuboid.max.x - _ray.origin.x) / _ray.direction.x;
    //float intersectMaxY = (_cuboid.max.y - _ray.origin.y) / _ray.direction.y;
    //float intersectMaxZ = (_cuboid.max.z - _ray.origin.z) / _ray.direction.z;

    //float intersectMin = max(intersectMinX, intersectMinY);
    //float intersectMax = min(intersectMinX, intersectMinY);

    //if (intersectMinX > intersectMaxY || intersectMinY > intersectMaxX)
    //    return;

    //if (intersectMin > intersectMaxZ || intersectMinZ > intersectMax)
    //    return;

    //if (intersectMinZ > intersectMin)
    //    intersectMin = intersectMinZ;

    //if (intersectMaxZ < intersectMax)
    //    intersectMax = intersectMaxZ;


    _rayHit.normal = _cuboid.colour;
    _rayHit.position =  float3(tXMin, tYMin, tZMin);
    _rayHit.distance = tXMin;
    _rayHit.normal -= (_rayHit.distance * 0.02f);


}



void IntersectGroundPlane(Ray _ray, inout RayHit _rayHit, float2 _texCoords) {
    float dist = -_ray.origin.y / _ray.direction.y;
    if (dist > 0 && dist < _rayHit.distance) {
        _rayHit.distance = dist;
        _rayHit.position = _ray.origin + dist * _ray.direction;
        _rayHit.normal = grassTexture.SampleLevel(sampler_grassTexture, _texCoords, 0).xyz;
        _rayHit.normal -= (dist * 0.02f);
    }
}

float3 Shade(inout Ray _ray, RayHit _rayHit) {
    if (_rayHit.distance < 999999) {
        return _rayHit.normal;
    }
    else {
        float theta = acos(_ray.direction.y) / -PI;
        float phi = atan2(_ray.direction.x, _ray.direction.z) / -PI * 0.5f;
        return skyboxTexture.SampleLevel(sampler_skyboxTexture, float2(phi, theta), 0).xyz;
    }
}

RayHit Trace(Ray _ray, float2 _texCoords) {
    RayHit rayHit = CreateRayHit();
    Cuboid cuboid = CreateCuboid(float3(0, 0, 0), float3(1, 3, 10), float3(0.5f, 0.5f, 0.2f));
    AABBIntersect(_ray, rayHit, cuboid);
    IntersectGroundPlane(_ray, rayHit, _texCoords);
    return rayHit;
}

void Lighting(Light _light, inout RayHit _rayHit) {
    _rayHit.normal -= saturate(dot(_rayHit.normal, _light.dir.xyz) * -1);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width;
    uint height;
    Result.GetDimensions(width, height);
    float2 texCoords = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    Light light = CreateLight(float3(0, 1, 0), float3(1, -0.5f, 0), float3(1, 1, 1), 1);

    Ray r = CreateCameraRay(texCoords);
    RayHit hit = Trace(r, texCoords);
    float3 result = Shade(r, hit);
    Lighting(light, hit);
    Result[id.xy] = float4(hit.normal.xyz, 1);
}
